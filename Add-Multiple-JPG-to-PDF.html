<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="Convert multiple JPG images to optimized PDF with smaller file size while maintaining quality. Free online tool with no quality loss.">
  <title>Optimized JPG to PDF Converter | Smaller File Size</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 20px;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    h1, h2 {
      color: #2c3e50;
    }
    .preview-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 15px 0;
    }
    .preview-item {
      position: relative;
    }
    .preview-item img {
      height: 100px;
      width: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .remove-btn {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 12px;
      cursor: pointer;
    }
    .upload-area {
      border: 2px dashed #3498db;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      margin: 15px 0;
      cursor: pointer;
    }
    button {
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
    }
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    .quality-options {
      margin: 15px 0;
    }
    .file-info {
      margin: 10px 0;
      font-size: 14px;
    }
    .optimization-tips {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Optimized JPG to PDF Converter</h1>
  <p>Convert multiple JPG images to PDF with smaller file size while maintaining visual quality</p>
  
  <div class="upload-area" id="uploadArea">
    <p>Drag & drop JPG images here or click to select files</p>
    <input type="file" id="fileInput" accept="image/jpeg" multiple style="display: none;" />
  </div>
  
  <div class="file-info" id="fileInfo">No files selected</div>
  
  <div class="quality-options">
    <label for="quality">Output Quality: </label>
    <select id="quality">
      <option value="0.9">High (recommended)</option>
      <option value="0.7">Medium</option>
      <option value="0.5">Low</option>
    </select>
    <span id="qualityInfo">(Balances quality and file size)</span>
  </div>
  
  <div class="preview-container" id="preview"></div>
  
  <button id="convertBtn" onclick="convertToPDF()" disabled>Convert to Optimized PDF</button>
  
  <div class="optimization-tips">
    <h3>File Size Optimization Tips:</h3>
    <ul>
      <li>Use "High" quality for important documents</li>
      <li>Use "Medium" quality for general sharing</li>
      <li>For web use, "Low" quality may be sufficient</li>
      <li>Each image will be automatically optimized</li>
    </ul>
  </div>
</div>

<script>
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const uploadArea = document.getElementById('uploadArea');
  const fileInfo = document.getElementById('fileInfo');
  const convertBtn = document.getElementById('convertBtn');
  const qualitySelect = document.getElementById('quality');
  const qualityInfo = document.getElementById('qualityInfo');
  let images = [];

  // Set up drag and drop
  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.style.backgroundColor = '#f0f8ff';
  });

  uploadArea.addEventListener('dragleave', () => {
    uploadArea.style.backgroundColor = '';
  });

  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.style.backgroundColor = '';
    fileInput.files = e.dataTransfer.files;
    handleFiles();
  });

  uploadArea.addEventListener('click', () => {
    fileInput.click();
  });

  fileInput.addEventListener('change', handleFiles);

  qualitySelect.addEventListener('change', (e) => {
    const quality = parseFloat(e.target.value);
    if (quality === 0.9) {
      qualityInfo.textContent = "(Best balance of quality and file size)";
    } else if (quality === 0.7) {
      qualityInfo.textContent = "(Good quality with smaller file size)";
    } else {
      qualityInfo.textContent = "(Smallest file size, noticeable quality loss)";
    }
  });

  function handleFiles() {
    images = [];
    preview.innerHTML = '';
    
    if (fileInput.files.length === 0) {
      fileInfo.textContent = 'No files selected';
      convertBtn.disabled = true;
      return;
    }
    
    fileInfo.textContent = `${fileInput.files.length} file(s) selected`;
    convertBtn.disabled = false;
    
    Array.from(fileInput.files).forEach((file) => {
      if (file.type === 'image/jpeg') {
        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function() {
            // Limit image dimensions to reduce memory usage
            const maxDimension = 2000; // Max width or height
            let width = img.width;
            let height = img.height;
            
            if (width > height && width > maxDimension) {
              height *= maxDimension / width;
              width = maxDimension;
            } else if (height > maxDimension) {
              width *= maxDimension / height;
              height = maxDimension;
            }
            
            // Create canvas with optimized dimensions
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Store canvas instead of full image to save memory
            images.push({
              element: img,
              canvas: canvas,
              width: width,
              height: height
            });
            
            createThumbnail(canvas.toDataURL('image/jpeg', 0.7), file.name);
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
  }

  function createThumbnail(dataUrl, filename) {
    const previewItem = document.createElement('div');
    previewItem.className = 'preview-item';
    
    const img = document.createElement('img');
    img.src = dataUrl;
    img.alt = filename;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.innerHTML = 'Ã—';
    removeBtn.onclick = (e) => {
      e.stopPropagation();
      previewItem.remove();
      images = images.filter(item => item.element.alt !== filename);
      fileInfo.textContent = `${images.length} file(s) remaining`;
      convertBtn.disabled = images.length === 0;
    };
    
    previewItem.appendChild(img);
    previewItem.appendChild(removeBtn);
    preview.appendChild(previewItem);
  }

  async function convertToPDF() {
    if (images.length === 0) {
      alert('Please upload at least one JPG image.');
      return;
    }

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'pt',
      format: 'a4',
      compress: true // Enable PDF compression
    });

    convertBtn.disabled = true;
    convertBtn.textContent = 'Optimizing PDF...';
    
    try {
      const quality = parseFloat(qualitySelect.value);
      
      for (let i = 0; i < images.length; i++) {
        const imgData = images[i];
        
        // Use the pre-scaled canvas from handleFiles
        const canvas = imgData.canvas;
        
        // Further optimize JPEG quality
        const optimizedDataUrl = canvas.toDataURL('image/jpeg', quality);
        
        // Calculate dimensions to fit A4 page
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        
        const ratio = Math.min(
          pdfWidth / canvas.width, 
          pdfHeight / canvas.height
        );
        
        const imgWidth = canvas.width * ratio;
        const imgHeight = canvas.height * ratio;
        
        const x = (pdfWidth - imgWidth) / 2;
        const y = (pdfHeight - imgHeight) / 2;

        if (i > 0) pdf.addPage();
        pdf.addImage(optimizedDataUrl, 'JPEG', x, y, imgWidth, imgHeight, undefined, 'FAST');
      }

      // Additional PDF compression options
      const blob = pdf.output('blob');
      const optimizedBlob = await furtherCompressPDF(blob);
      
      // Create download link
      const url = URL.createObjectURL(optimizedBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `optimized-${new Date().toISOString().slice(0,10)}.pdf`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
    } catch (error) {
      console.error('Conversion error:', error);
      alert('Error during conversion. Please try again with fewer or smaller images.');
    } finally {
      convertBtn.disabled = false;
      convertBtn.textContent = 'Convert to Optimized PDF';
    }
  }

  async function furtherCompressPDF(blob) {
    // This is a placeholder for additional compression techniques
    // In a real implementation, you might use:
    // 1. A PDF compression library
    // 2. WebAssembly-based compression
    // 3. Or just return the original blob if no additional compression is needed
    
    // For this example, we'll just return the original blob
    return blob;
    
    /* In a production environment, you might use something like:
    try {
      const pdf = await PDFLib.PDFDocument.load(await blob.arrayBuffer());
      // Apply compression settings here
      const compressedBytes = await pdf.save({
        useObjectStreams: true,
        // Other compression options...
      });
      return new Blob([compressedBytes], { type: 'application/pdf' });
    } catch (e) {
      console.warn('Additional compression failed, using original PDF', e);
      return blob;
    }
    */
  }
</script>

</body>
</html>
